# Copyright © VASP Software GmbH,
# Licensed under the Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
import numpy as np

from py4vasp import _config, exception
from py4vasp._calculation import base, slice_, structure
from py4vasp._third_party import view
from py4vasp._util import check, documentation, select

_index_note = """\
Notes
-----
The index order is different compared to the raw data when noncollinear calculations
are used. This routine returns the magnetic moments as (steps, orbitals, atoms,
directions)."""

_moment_selection = """\
selection : str
    If VASP was run with LORBMOM = T, the orbital moments are computed and the routine
    will default to the total moments. You can specify "spin" or "orbital" to select
    the individual contributions instead.
"""

_ORBITAL_PROJECTION = "orbital_projection"


class LocalMoment(slice_.Mixin, base.Refinery, structure.Mixin, view.Mixin):
    """The local moments describe the charge and magnetization near an atom.

    The projection on local moments is particularly relevant in the context of
    magnetic materials. It analyzes the electronic states in the vicinity of an
    atom by projecting the electronic orbitals onto the localized projectors of
    the PAWs. The local moments help understanding the magnetic ordering, the spin
    polarization, and the influence of neighboring atoms on the magnetic behavior.

    This class allows to access the computed moments from a VASP calculation.
    Remember that VASP calculates the projections only if you need to set
    :tag:`LORBIT` in the INCAR file. If the system is computed without spin
    polarization, the resulting moments correspond only to the local charges
    resolved by angular momentum. For collinear calculation, additionally the
    magnetic moment are computed. In noncollinear calculations, the magnetization
    becomes a vector. When comparing the results extracted from VASP to experimental
    observation, please be aware that the finite size of the radius in the projection
    may influence the observed moments. Hence, there is no one-to-one correspondence
    to the experimental moments.

    Examples
    --------
    Let us create some example data so that we can illustrate how to use this class.
    Of course you can also use your own VASP calculation data if you have it available.

    >>> from py4vasp import demo
    >>> calculation = demo.calculation(path, "collinear")

    If you access the local moments, the result will depend on the steps that you selected
    with the [] operator. Without any selection the results from the final step will be
    used.

    >>> calculation.local_moment.number_steps()
    1

    To select the results for all steps, you don't specify the array boundaries.

    >>> calculation.local_moment[:].number_steps()
    4

    You can also select specific steps or a subset of steps as follows

    >>> calculation.local_moment[3].number_steps()
    1
    >>> calculation.local_moment[1:4].number_steps()
    3
    """

    _missing_data_message = "Atom resolved magnetic information not present, please verify LORBIT tag is set."

    length_moments = 1.5
    "Length in Å how a magnetic moment is displayed relative to the largest moment."

    @base.data_access
    def __str__(self):
        if self._is_nonpolarized:
            return "not spin polarized"
        magmom = "MAGMOM = "
        moments_last_step = self.magnetic("spin")
        moments_to_string = lambda vec: " ".join(f"{moment:.2f}" for moment in vec)
        if moments_last_step.ndim == 1:
            return magmom + moments_to_string(moments_last_step)
        else:
            separator = " \\\n         "
            generator = (moments_to_string(vec) for vec in moments_last_step)
            return magmom + separator.join(generator)

    @base.data_access
    @documentation.format(index_note=_index_note)
    def to_dict(self):
        """Read the charges and magnetization data into a dictionary.

        Be careful when comparing the magnetic moments to experimental data. The
        finite size of the projection sphere may influence the observed moments. Hence,
        there is no one-to-one correspondence to the experimental moments.

        Returns
        -------
        dict
            Contains the charges and magnetic moments generated by VASP projected
            on atoms and orbitals.

        {index_note}

        Examples
        --------
        First we create some example data so that we can illustrate how to use this method.
        Of course you can also use your own VASP calculation data if you have it available.

        >>> from py4vasp import demo
        >>> collinear_calculation = demo.calculation(path, "collinear")
        >>> noncollinear_calculation = demo.calculation(path, "noncollinear")

        If you use the `to_dict` method, the result will depend on the steps that you
        selected with the [] operator. Without any selection the results from the final
        step will be used.

        >>> collinear_calculation.local_moment.to_dict()
        {{'orbital_projection': ['s', 'p', 'd'], 'charge': array([[...]]),
            'total': array([[...]])}}

        To select the results for all steps, you don't specify the array boundaries.
        Notice that in this case the charge and the total moment contain an additional
        dimension for the different steps.

        >>> collinear_calculation.local_moment[:].to_dict()
        {{'orbital_projection': ['s', 'p', 'd'], 'charge': array([[[...]]]),
            'total': array([[[...]]])}}

        You can also select specific steps or a subset of steps as follows

        >>> collinear_calculation.local_moment[2].to_dict()
        {{'orbital_projection': ['s', 'p', 'd'], 'charge': array([[...]]),
            'total': array([[...]])}}
        >>> collinear_calculation.local_moment[0:3].to_dict()
        {{'orbital_projection': ['s', 'p', 'd'], 'charge': array([[[...]]]),
            'total': array([[[...]]])}}

        For noncollinear calculations, the magnetic moments are vectors. In addition,
        if the calculation was run with LORBMOM = T, orbital and spin moments are
        reported separately.

        >>> noncollinear_calculation.local_moment.to_dict()
        {{'orbital_projection': ['s', 'p', 'd'], 'charge': array([[...]]),
            'total': array([[[...]]]), 'spin': array([[[...]]]), 'orbital': array([[[...]]])}}
        """
        return {
            _ORBITAL_PROJECTION: self.selections()[_ORBITAL_PROJECTION],
            "charge": self.projected_charge(),
            **self._add_total_magnetic_moment(),
            **self._add_spin_and_orbital_moments(),
        }

    @base.data_access
    @documentation.format(selection=_moment_selection)
    def to_view(self, selection="total", supercell=None):
        """Visualize the magnetic moments as arrows inside the structure.

        Be aware that the magnetic moments are rescaled for better visibility. The length
        of the largest moment is set to :attr:`length_moments`. If your moments are
        vanishingly small, this may lead to unexpectedly large arrows. Please double check
        the actual values with :meth:`magnetic`.

        Parameters
        ----------
        {selection}

        Returns
        -------
        View
            Contains the atoms and the unit cell as well as an arrow indicating the
            strength of the magnetic moment. If noncollinear magnetism is used
            the moment points in the actual direction; for collinear magnetism
            the moments are aligned along the z axis by convention.

        Examples
        --------
        First we create some example data so that we can illustrate how to use this method.
        Of course you can also use your own VASP calculation data if you have it available.

        >>> from py4vasp import demo
        >>> collinear_calculation = demo.calculation(path, "collinear")
        >>> noncollinear_calculation = demo.calculation(path, "noncollinear")

        If you use the `to_view` method, the result will depend on the steps that you
        selected with the [] operator. Without any selection the results from the final
        step will be used.

        >>> collinear_calculation.local_moment.to_view()
        View(..., ion_arrows=[IonArrow(quantity=array([[[...]]]), label='total moments', ...)], ...)

        For collinear calculations, the magnetic moments are scalars aligned along the
        z axis. You can see this from the arrows pointing either up or down or x and y
        components being zero.

        To select the results for all steps, you don't specify the array boundaries.

        >>> collinear_calculation.local_moment[:].to_view()
        View(..., ion_arrows=[IonArrow(quantity=array([[[...]]]), label='total moments', ...)], ...)

        You can also select specific steps or a subset of steps as follows

        >>> collinear_calculation.local_moment[2].to_view()
        View(..., ion_arrows=[IonArrow(quantity=array([[[...]]]), label='total moments', ...)], ...)
        >>> collinear_calculation.local_moment[0:3].to_view()
        View(..., ion_arrows=[IonArrow(quantity=array([[[...]]]), label='total moments', ...)], ...)

        For noncollinear calculations, the magnetic moments are aligned according to
        the spin axis (:tag:`SAXIS`). The view has the same interface, but the arrows now
        point in the actual direction of the magnetic moments.

        >>> noncollinear_calculation.local_moment.to_view()
        View(..., ion_arrows=[IonArrow(quantity=array([[[...]]]), label='total moments', ...)], ...)

        You can also select spin or orbital moments separately.
        >>> noncollinear_calculation.local_moment.to_view(selection="spin, orbital")
        View(..., ion_arrows=[IonArrow(quantity=array([[[...]]]), label='spin moments', ...),
            IonArrow(quantity=array([[[...]]]), label='orbital moments', ...)], ...)
        """
        viewer = self._structure[self._steps].plot(supercell)
        if not self._is_nonpolarized:
            viewer.ion_arrows = list(
                self._prepare_magnetic_moments_for_plotting(selection)
            )
        return viewer

    @base.data_access
    def projected_charge(self):
        """Read the orbital- and site-projected charges of the selected steps.

        Returns
        -------
        np.ndarray
            Contains the charges for the selected steps projected on atoms and orbitals.

        Examples
        --------
        First we create some example data so that we can illustrate how to use this method.
        Of course you can also use your own VASP calculation data if you have it available.

        >>> from py4vasp import demo
        >>> calculation = demo.calculation(path, "collinear")

        If you use the `projected_charge` method, the result will depend on the steps that you
        selected with the [] operator. Without any selection the results from the final
        step will be used.

        >>> calculation.local_moment.projected_charge()
        array([[...]])

        To select the results for all steps, you don't specify the array boundaries.
        Notice that in this case the charge contains an additional dimension for the
        different steps.

        >>> calculation.local_moment[:].projected_charge()
        array([[[...]]])
        """
        self._raise_error_if_steps_out_of_bounds()
        return self._raw_data.spin_moments[self._steps, 0]

    @base.data_access
    @documentation.format(selection=_moment_selection, index_note=_index_note)
    def projected_magnetic(self, selection="total"):
        """Read the orbital- and site-projected magnetic moments of the selected steps.

        Parameters
        ----------
        {selection}

        Returns
        -------
        np.ndarray
            Contains the magnetic moments for the selected steps projected on atoms and
            orbitals.

        {index_note}

        Examples
        --------
        First we create some example data so that we can illustrate how to use this method.
        Of course you can also use your own VASP calculation data if you have it available.

        >>> from py4vasp import demo
        >>> collinear_calculation = demo.calculation(path, "collinear")
        >>> noncollinear_calculation = demo.calculation(path, "noncollinear")

        If you use the `projected_magnetic` method, the result will depend on the steps that you
        selected with the [] operator. Without any selection the results from the final
        step will be used.

        >>> collinear_calculation.local_moment.projected_magnetic()
        array([[...]])

        To select the results for all steps, you don't specify the array boundaries.

        >>> collinear_calculation.local_moment[:].projected_magnetic()
        array([[[...]]])

        You can also select specific steps or a subset of steps as follows

        >>> collinear_calculation.local_moment[2].projected_magnetic()
        array([[...]])
        >>> collinear_calculation.local_moment[0:3].projected_magnetic()
        array([[[...]]])

        To select the results for all steps, you don't specify the array boundaries.

        >>> collinear_calculation.local_moment[:].projected_magnetic()
        array([[[...]]])

        For noncollinear calculations, the magnetic moments are aligned according to
        the spin axis (:tag:`SAXIS`). Since the moments are now vectors, the result
        has an additional dimension for the different directions.

        >>> noncollinear_calculation.local_moment.projected_magnetic()
        array([[[...]]])

        You can also select spin or orbital moments separately.
        >>> noncollinear_calculation.local_moment.projected_magnetic(selection="spin")
        array([[[...]]])
        """
        self._raise_error_if_steps_out_of_bounds()
        self._raise_error_if_no_magnetic_moments()
        tree = select.Tree.from_selection(selection)
        moments = [self._magnetic_moments(selection) for selection in tree.selections()]
        return np.squeeze(moments)

    @base.data_access
    def charge(self):
        """Read the site-projected charges of the selected steps.

        Returns
        -------
        np.ndarray
            Contains the charges for the selected steps projected on atoms. Equivalent
            to summing the projected charges over the orbitals.

        Examples
        --------
        First we create some example data so that we can illustrate how to use this method.
        Of course you can also use your own VASP calculation data if you have it available.

        >>> from py4vasp import demo
        >>> calculation = demo.calculation(path, "collinear")

        If you use the `charge` method, the result will depend on the steps that you
        selected with the [] operator. Without any selection the results from the final
        step will be used.

        >>> calculation.local_moment.charge()
        array([...])

        To select the results for all steps, you don't specify the array boundaries.
        Notice that in this case the charge contains an additional dimension for the
        different steps.

        >>> calculation.local_moment[:].charge()
        array([[...]])

        The charge is equivalent to summing the projected charges over the orbitals

        >>> np.allclose(calculation.local_moment.charge(),
        ...     calculation.local_moment.projected_charge().sum(axis=-1))
        True
        """
        return _sum_over_orbitals(self.projected_charge())

    @base.data_access
    @documentation.format(selection=_moment_selection, index_note=_index_note)
    def magnetic(self, selection="total"):
        """Read the site-projected magnetic moments of the selected steps.

        Be careful when comparing the magnetic moments to experimental data. The
        finite size of the projection sphere may influence the observed moments. Hence,
        there is no one-to-one correspondence to the experimental moments.

        Parameters
        ----------
        {selection}

        Returns
        -------
        np.ndarray
            Contains the magnetic moments for the selected steps projected on atoms.
            Equivalent to summing the projected magnetic moments over the orbitals.

        {index_note}

        Examples
        --------
        First we create some example data so that we can illustrate how to use this method.
        Of course you can also use your own VASP calculation data if you have it available.

        >>> from py4vasp import demo
        >>> collinear_calculation = demo.calculation(path, "collinear")
        >>> noncollinear_calculation = demo.calculation(path, "noncollinear")

        If you use the `magnetic` method, the result will depend on the steps that you
        selected with the [] operator. Without any selection the results from the final
        step will be used.

        >>> collinear_calculation.local_moment.magnetic()
        array([...])

        To select the results for all steps, you don't specify the array boundaries.

        >>> collinear_calculation.local_moment[:].magnetic()
        array([[...]])

        You can also select specific steps or a subset of steps as follows

        >>> collinear_calculation.local_moment[2].magnetic()
        array([...])
        >>> collinear_calculation.local_moment[0:3].magnetic()
        array([[...]])

        To select the results for all steps, you don't specify the array boundaries.

        >>> collinear_calculation.local_moment[:].magnetic()
        array([[...]])

        For noncollinear calculations, the magnetic moments are aligned according to
        the spin axis (:tag:`SAXIS`). Since the moments are now vectors, the result
        has an additional dimension for the different directions.

        >>> noncollinear_calculation.local_moment.magnetic()
        array([[...]])

        You can also select spin or orbital moments separately.
        >>> noncollinear_calculation.local_moment.magnetic(selection="spin")
        array([[...]])

        The magnetic moment is equivalent to summing the projected magnetic moments over
        the orbitals

        >>> np.allclose(collinear_calculation.local_moment.magnetic(),
        ...     collinear_calculation.local_moment.projected_magnetic().sum(axis=-1))
        True
        """
        return _sum_over_orbitals(
            self.projected_magnetic(selection), is_vector=self._is_noncollinear
        )

    @base.data_access
    def selections(self):
        result = super().selections()
        if self._raw_data.spin_moments.shape[-1] == 4:
            result[_ORBITAL_PROJECTION] = ["s", "p", "d", "f"]
        else:
            result[_ORBITAL_PROJECTION] = ["s", "p", "d"]
        if self._is_nonpolarized:
            result["component"] = ["charge"]
        elif self._has_orbital_moments:
            result["component"] = ["charge", "total", "spin", "orbital"]
        else:
            result["component"] = ["charge", "total", "spin"]
        return result

    @base.data_access
    def number_steps(self):
        """Return the number of local moments in the trajectory."""
        range_ = range(len(self._raw_data.spin_moments))
        return len(range_[self._slice])

    @property
    def _is_nonpolarized(self):
        return self._raw_data.spin_moments.shape[1] == 1

    @property
    def _is_collinear(self):
        return self._raw_data.spin_moments.shape[1] == 2

    @property
    def _is_noncollinear(self):
        return self._raw_data.spin_moments.shape[1] == 4

    @property
    def _has_orbital_moments(self):
        return not check.is_none(self._raw_data.orbital_moments)

    def _magnetic_moments(self, selection):
        self._raise_error_if_selection_not_available(selection)
        if self._is_collinear:
            return self._spin_moments()
        else:
            return self._noncollinear_moments(selection[0])

    def _noncollinear_moments(self, selection):
        spin_moments = self._spin_moments()
        orbital_moments = self._orbital_moments(spin_moments)
        if selection == "orbital":
            moments = orbital_moments
        elif selection == "spin":
            moments = spin_moments
        else:  # total
            moments = spin_moments + orbital_moments
        direction_axis = 1 if moments.ndim == 4 else 0
        return np.moveaxis(moments, direction_axis, -1)

    def _spin_moments(self):
        return self._raw_data.spin_moments[self._steps, 1:]

    def _orbital_moments(self, spin_moments):
        if not self._has_orbital_moments:
            return np.zeros_like(spin_moments)
        zero_s_moments = np.zeros((*spin_moments.shape[:-1], 1))
        orbital_moments = self._raw_data.orbital_moments[self._steps]
        return np.concatenate((zero_s_moments, orbital_moments), axis=-1)

    def _add_total_magnetic_moment(self):
        if self._is_nonpolarized:
            return {}
        return {"total": self.projected_magnetic()}

    def _add_spin_and_orbital_moments(self):
        if not self._has_orbital_moments:
            return {}
        spin_moments = self._spin_moments()
        orbital_moments = self._orbital_moments(spin_moments)
        direction_axis = 1 if spin_moments.ndim == 4 else 0
        return {
            "spin": np.moveaxis(spin_moments, direction_axis, -1),
            "orbital": np.moveaxis(orbital_moments, direction_axis, -1),
        }

    def _prepare_magnetic_moments_for_plotting(self, selection):
        tree = select.Tree.from_selection(selection)
        for (selection, *_) in tree.selections():
            moments = self.magnetic(selection)
            moments = self._make_sure_moments_have_timestep_dimension(moments)
            moments = _convert_moment_to_3d_vector(moments)
            max_length_moments = _max_length_moments(moments)
            if max_length_moments > 1e-15:
                rescale_moments = LocalMoment.length_moments / max_length_moments
                yield view.IonArrow(
                    quantity=rescale_moments * moments,
                    label=f"{selection} moments",
                    color=_color(selection),
                    radius=0.2,
                )

    def _make_sure_moments_have_timestep_dimension(self, moments):
        if not self._is_slice and moments is not None:
            moments = moments[np.newaxis]
        return moments

    def _raise_error_if_steps_out_of_bounds(self):
        try:
            np.zeros(self._raw_data.spin_moments.shape[0])[self._steps]
        except IndexError as error:
            raise exception.IncorrectUsage(
                f"Error reading the magnetic moments. Please check if the steps "
                f"`{self._steps}` are properly formatted and within the boundaries."
            ) from error

    def _raise_error_if_no_magnetic_moments(self):
        if self._is_nonpolarized:
            raise exception.NoData(
                "There are no magnetic moments in the data. Please make sure that you "
                "either set ISPIN = 2 or LNONCOLLINEAR = T or LSORBIT = T."
            )

    def _raise_error_if_selection_not_available(self, selection):
        if len(selection) != 1:
            raise exception.IncorrectUsage()
        selection = selection[0]
        if selection not in ("spin", "orbital", "total"):
            raise exception.IncorrectUsage(
                f"The selection {selection} is incorrect. Please check if it is spelled "
                "correctly. Possible choices are total, spin, or orbital."
            )
        if selection != "orbital" or self._has_orbital_moments:
            return
        raise exception.NoData(
            "There are no orbital moments in the VASP output. Please make sure that you "
            "run the calculation with LORBMOM = T and LSORBIT = T."
        )


def _sum_over_orbitals(quantity, is_vector=False):
    if quantity is None:
        return None
    if is_vector:
        return np.sum(quantity, axis=-2)
    return np.sum(quantity, axis=-1)


def _convert_moment_to_3d_vector(moments):
    if moments is not None and moments.ndim == 2:
        moments = moments.reshape((*moments.shape, 1))
        no_new_moments = (0, 0)
        add_zero_for_xy_axis = (2, 0)
        padding = (no_new_moments, no_new_moments, add_zero_for_xy_axis)
        moments = np.pad(moments, padding)
    return moments


def _max_length_moments(moments):
    if moments is not None:
        return np.max(np.linalg.norm(moments, axis=2))
    else:
        return 0.0


def _color(selection):
    if selection == "total":
        return _config.VASP_COLORS["blue"]
    if selection == "spin":
        return _config.VASP_COLORS["purple"]
    if selection == "orbital":
        return _config.VASP_COLORS["red"]
    raise exception.IncorrectUsage(f"Unknown component {selection} selected.")
